/*************************************************************************************************************************************************************************
  Easy Bitx HF Dual Band Rigs(40m/20m) VFO / BFO sketch with Si5351 and Arduino Nano with 10Mhz IF.
  Hardware VU3SUA VFO/BFO Board with 16X2 LCD
  Nitin William - VU3GAO September/2021 - Version 1.5
  Code derived from J. CesarSound - ver 1.0 - Dec/2020.
  https://groups.io/g/BITX20/topic/bitx_40_dds_vfo/4104090?p=
*************************************************************************************************************************************************************************/

//Libraries
#include <Wire.h>                 //IDE Standard
#include <Rotary.h>               //Ben Buxton https://gthub.com/brianlow/Rotary
#include <si5351.h>               //Etherkit https://github.com/etherkit/Si5351Arduino
#include <EasyButton.h>           //https://easybtn.earias.me/docs/introduction
#include <LiquidCrystal.h>        //IDE Standard


#define ddsCal 359000
#define LCD_RS  5
#define LCD_E   6
#define LCD_D4  7
#define LCD_D5  8
#define LCD_D6  9
#define LCD_D7  10
#define encoderButtonPin 11
#define filterRlyPin 4
#define smeterPin A0

unsigned long fMax = 0UL;
unsigned long fMin = 0UL;
unsigned long vfo = 0UL;
unsigned long bfo = 9996800UL;   //BFO frequency for 10Mhz filter Bw = 3.2Khz
unsigned long opsfreq = 0UL;     //Operating freq to be generated by Si5351
unsigned long freqold, fstep;
float dummy;                     //Dummy variable to store ADC first sample. This is to stablize the reading by giving time to multiplexer. Use second reading
float smRead;                    //S meter reading
int smr;                         //Ring fenced S meter reading for Bar graph
int stp;                         //Frequency step counter
int band;
byte bar[8] =
{
  B11111,
  B11111,
  B11111,
  B11111,
  B11111,
  B11111,
  B11111,
  B00000
};
byte blank[8] =
{
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
  B00000,
  B00000
};
byte tower[8] =
{
  B11111,
  B10101,
  B01110,
  B00100,
  B00100,
  B00100,
  B00100,
  B00000
};
byte lsb[8] =
{
  B00010,
  B00010,
  B00011,
  B00000,
  B00011,
  B00010,
  B00001,
  B00011
};
byte usb[8] =
{
  B00101,
  B00101,
  B00111,
  B00000,
  B00011,
  B00010,
  B00001,
  B00011
};


Rotary r = Rotary(3, 2);         // Encoder defined for Interrupt Pin 2,3
LiquidCrystal lcd(LCD_RS, LCD_E, LCD_D4, LCD_D5, LCD_D6, LCD_D7);
Si5351 si5351(0x60);             //Si5351 I2C Address 0x60
EasyButton encoderButton (encoderButtonPin, true); //Create encoderButton Object as input with internal pullup resistors


ISR(PCINT2_vect)
{
  char result = r.process();
  if (result == DIR_CW) set_frequency(1);
  else if (result == DIR_CCW) set_frequency(-1);
}


void set_frequency(short dir)
{
  if (dir == 1) vfo = vfo + fstep;
  if (vfo >= fMax) vfo = fMax;                            //Upper tuning limit
  if (dir == -1) vfo = vfo - fstep;
  if (vfo < fMin) vfo = fMin;                             //lower tuning limit
}


void setup()
{
  Serial.begin(57600);
  encoderButton.begin();
  Wire.begin();
  r.begin(true);                                         //Enable the Arduino's internal weak pull-ups for the rotary's pins external pullup
  pinMode(smeterPin, INPUT);                             //Set A0 as analog input pin
  pinMode(filterRlyPin, OUTPUT);                           //Set D4 as digital output for band relay
  lcd.begin(16, 2);
  delay (20);
  lcd.createChar(0, tower);
  lcd.createChar(1, blank);
  lcd.createChar(2, bar);
  lcd.createChar(3, lsb);
  lcd.createChar(4, usb);
  lcd.clear();
  si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, ddsCal);       //Initialize Si5351, with 25Mhz Xtal
  si5351.set_pll(SI5351_PLL_FIXED, SI5351_PLLA);
  si5351.drive_strength(SI5351_CLK0, SI5351_DRIVE_6MA);  //Output current 2MA, 4MA, 6MA or 8MA
  si5351.drive_strength(SI5351_CLK2, SI5351_DRIVE_6MA);  //Output current 2MA, 4MA, 6MA or 8MA
  si5351.output_enable(SI5351_CLK0, 1);                  //1 - Enable / 0 - Disable CLK
  si5351.output_enable(SI5351_CLK1, 0);
  si5351.output_enable(SI5351_CLK2, 1);
  si5351.update_status();
  cli();
  PCICR |= (1 << PCIE2);
  PCMSK2 |= (1 << PCINT18) | (1 << PCINT19);
  sei();                                                // Enable all interrupts
  display_banner();
  si5351.set_freq(bfo * 100, SI5351_CLK2);              //Set bfo
  stp = 4;
  setsteps();
  band = 1;
  setbands();
  encoderButton.onPressed(setsteps);
  encoderButton.onPressedFor(2000, set_bfo);
  encoderButton.onSequence (2, 500, setbands);
  tunegen();
  display_freq();
  display_radix();
}


void loop()
{
  encoderButton.read();
  if (freqold != vfo)
  {
    tunegen();
    freqold = vfo;
  }
  display_freq();
  display_radix();
  display_smeter();
  flash_heart();
}


void setsteps()
{
  switch (stp)
  {
    case 1: stp = 2; fstep = 1; break;
    case 2: stp = 3; fstep = 10; break;
    case 3: stp = 4; fstep = 100; break;
    case 4: stp = 5; fstep = 1000; break;
    case 5: stp = 1; fstep = 10000; break;
  }
}


void tunegen()
{
  if (vfo >= 14000000 )
  {
    opsfreq =  vfo - bfo;                                //Low side LO injection, no side band inversion
    si5351.set_freq(opsfreq * 100, SI5351_CLK0);         //Update operating frequency
    lcd.setCursor(1, 0);
    lcd.write(byte(4));
  }
  if (vfo < 8000000 )
  {
    opsfreq =  vfo + bfo;                                //High side LO injection, Side band inversion
    si5351.set_freq(opsfreq * 100, SI5351_CLK0);         //Update operating frequency
    lcd.setCursor(1, 0);
    lcd.write(byte(3));
  }
}


void display_freq()
{
  uint16_t f;
  lcd.setCursor(3, 0);
  f = vfo / 1000000;
  if (f < 10)
    lcd.print('0');
  lcd.print(f);
  lcd.print('.');
  f = (vfo % 1000000) / 1000;
  if (f < 100)
    lcd.print('0');
  if (f < 10)
    lcd.print('0');
  lcd.print(f);
  lcd.print('.');
  f = vfo % 1000;
  if (f < 100)
    lcd.print('0');
  if (f < 10)
    lcd.print('0');
  lcd.print(f);
  lcd.print(" Hz");
}


void display_radix()
{
  lcd.setCursor(13, 1);
  if (stp == 2) lcd.print(" 01"); if (stp == 3) lcd.print(" 10"); if (stp == 4) lcd.print("100");
  if (stp == 5) lcd.print(" 1K"); if (stp == 1) lcd.print("10K");
}


void flush_input(void)
{
  while (Serial.available() > 0)
  Serial.read();
}


void set_bfo(void)
{
  lcd.clear();
  lcd.setCursor(3, 0);
  lcd.print("BFO  SETUP");
  Serial.print(F("Current BFO frequency is (Hz):"));
  Serial.println(bfo);
  Serial.println(F("Press w for increment in steps of 100Hz"));
  Serial.println(F("Press o for decrement in steps of 100Hz"));
  Serial.println(F("Press s for increment in steps of 10Hz"));
  Serial.println(F("Press l for decrement in steps of 10Hz"));
  Serial.println(F("Press q once done and note the final BFO"));
  while (1)
  {
    if (Serial.available() > 0)
    {
      char c = Serial.read();
      switch (c)
      {
        case 'q':
          flush_input();
          Serial.println();
          Serial.print(F("Final BFO frequency is (Hz):"));
          Serial.println(bfo);
          Serial.println();
          si5351.set_freq(bfo * 100, SI5351_CLK2);              //BFO
          return;
        case 'w': bfo += 100; break;
        case 'o': bfo -= 100; break;
        case 's': bfo += 10; break;
        case 'l': bfo -= 10; break;
        default:
          continue;
      }
      si5351.set_freq(bfo * 100, SI5351_CLK2);                  //Set running BFO
      Serial.print(F("BFO running at(Hz):"));
      Serial.println(bfo);
    }
  }
}


void display_banner()
{
  lcd.setCursor (3, 0);
  lcd.print("Easy Bitx");
  lcd.setCursor (3, 1);
  lcd.print("Dual Band");
  delay (2000);
  lcd.clear();
}


void display_smeter ()
{
  lcd.setCursor (0, 1);
  lcd.print ("S");
  dummy = analogRead(smeterPin);        // Read smeter and dump
  smRead = analogRead(smeterPin);       // Read smeter, Compute Voltage from ADC Reading
  smr = map (smRead, 0, 1023, 1, 10); if (smr > 10) smr = 10;
  if ( smr <= 9)
  {
    lcd.print (smr); lcd.print (" ");
  }
  else
    lcd.print ("9+");
  for (int x = 1; x <= smr; x ++)
  {
    lcd.write (byte(2));
  }
  for (int y = 9; y >= smr; y --)
  {
    lcd.write (byte(1));
  }
}


void flash_heart()
{
  lcd.setCursor (0, 0);
  lcd.write (byte((millis() / 1000) % 2 ));        //Logic give 0 or 1 as paramtere to function byte()
}


void setbands()
{
  switch (band)
  {
    case 1:
      band = 2;
      vfo = 7050000;
      fMax = 7300000;
      fMin = 7000000;
      digitalWrite (filterRlyPin, LOW);
      break;
    case 2:
      band = 1;
      vfo = 14200000;
      fMax = 14350000;
      fMin = 14000000;
      digitalWrite (filterRlyPin, HIGH);
      break;
  }
}
